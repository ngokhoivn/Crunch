# Bài 38: Áp dụng sát thương

### **1. Tránh trùng lặp Actor khi tấn công**

- **Vấn đề**: Khi thực hiện nhiều đợt tấn công (sweeps), một Actor có thể bị trúng đòn nhiều lần, dẫn đến tính sát thương bị áp dụng nhiều lần không mong muốn.
- **Giải pháp**:
    - Sử dụng **`TSet<AActor*>`** để lưu trữ các Actor đã bị trúng đòn.
    
    ```cpp
    TSet<AActor*> HitActors; // Để tránh trùng lặp Actor trong kết quả
    ```
    
    - Kiểm tra trước khi áp dụng sát thương:
        
        ```cpp
        		for (const FHitResult& Result : Results)
        		{
        			if (HitActors.Contains(Result.GetActor()))
        			{
                        continue; // Bỏ qua nếu Actor đã bị trúng đòn trước đó
        			}
        
        			HitActors.Add(Result.GetActor()); // Thêm Actor vào HitActors nếu chưa bị trúng
        			OutResult.Add(Result); // Thêm kết quả va chạm vào mảng kết quả
        		}
        ```
        

### **2. Áp dụng sát thương khác nhau cho từng Combo**

- **Mục tiêu**: Mỗi đòn đánh trong Combo gây sát thương khác nhau.
- **Cách triển khai**:
    - Sử dụng **`TMap<FName, TSubclassOf<UGameplayEffect>>`** để ánh xạ tên Combo (Section Name) với hiệu ứng sát thương tương ứng.
    
    ```cpp
    	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effect")
    	TMap<FName, TSubclassOf<UGameplayEffect>> DamageEffectMap; // Map tên combo sang GameplayEffect
    
    	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effect")
    	TSubclassOf<UGameplayEffect> DefaultDamageEffect; // Hiệu ứng mặc định nếu không tìm thấy trong DamageEffectMap
    ```
    
    - Hàm trợ giúp **`GetDamageEffectForCurrentCombo()`**:
        
        ```cpp
        TSubclassOf<UGameplayEffect> GetDamageEffectForCurrentCombo() const; // Lấy hiệu ứng damage cho combo hiện tại
        
        TSubclassOf<UGameplayEffect> UGA_Combo::GetDamageEffectForCurrentCombo() const
        {
        	UAnimInstance* OwnerAnimInstance = GetOwnerAnimInstance();
        	if (!OwnerAnimInstance)
        	{
        		FName CurrentSectionName = OwnerAnimInstance->Montage_GetCurrentSection(ComboMontage);
        		const TSubclassOf<UGameplayEffect>* FoundEffectPtr = DamageEffectMap.Find(CurrentSectionName);
        		if (FoundEffectPtr)
        		{
        			return *FoundEffectPtr;
        		}
        	}
        	return DefaultDamageEffect;
        }
        ```
        
    - Áp dụng hiệu ứng sát thương:
        
        ```cpp
        	for (const FHitResult& HitResult : HitResults)
        	{
        		TSubclassOf<UGameplayEffect> GameplayEffect = GetDamageEffectForCurrentCombo();
        		FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec( 
        			GameplayEffect, 
        			GetAbilityLevel(GetCurrentAbilitySpecHandle(), 
        			GetCurrentActorInfo())
        		);
        
        		ApplyGameplayEffectSpecToTarget(
        			GetCurrentAbilitySpecHandle(),
        			CurrentActorInfo,
        			CurrentActivationInfo,
        			EffectSpecHandle,
        			UAbilitySystemBlueprintLibrary::AbilityTargetDataFromActor(HitResult.GetActor()));
        	}
        ```
        

### **3. Tạo Gameplay Effects cho Combo**

- **Tạo các Blueprint Gameplay Effect**:
    - **`GE_Combo01_Damage`**: -10 HP (Combo đầu tiên).
    - **`GE_Combo02_Damage`**: -20 HP (Combo thứ hai).
    - **`GE_Combo03_Damage`**: -30 HP (Combo thứ ba).
    - **`GE_Combo04_Damage`**: -40 HP (Combo cuối).
- **Gán vào Damage Effect Map**:
    - Ánh xạ Section Name (**`Combo01`**, **`Combo02`**, ...) với các Gameplay Effect tương ứng.

### **4. Kiểm thử**

- **Kết quả**:
    - Sát thương được áp dụng chính xác theo từng đòn Combo.
    - Server xử lý sát thương và replicate xuống Client.
- **Vấn đề còn tồn tại**:
    - HP có thể giảm dưới 0 (cần clamp giá trị).
    - Thiếu hiệu ứng hình ảnh (particle, camera shake, animation phản ứng).

### **5. Code**

```cpp
//CGameplayAbility.cpp

#include "GAS/CGameplayAbility.h"
#include "Components/SkeletalMeshComponent.h"
#include "Kismet/KismetSystemLibrary.h"

UAnimInstance* UCGameplayAbility::GetOwnerAnimInstance() const
{
    USkeletalMeshComponent* OwnerSkeletalMeshComp = GetOwningComponentFromActorInfo();
    if (OwnerSkeletalMeshComp)
    {
        return OwnerSkeletalMeshComp->GetAnimInstance();
    }

    return nullptr;
}

TArray<FHitResult> UCGameplayAbility::GetHitResultsFromSweepLocationTargetData(const FGameplayAbilityTargetDataHandle& TargetDataHandle, float SphereSweepRadius, bool bDrawDebug, bool bIgnoreSelf) const
{
    TArray<FHitResult> OutResult;
	TSet<AActor*> HitActors; // Để tránh trùng lặp Actor trong kết quả

    // 1. Duyệt qua từng TargetData (mỗi cặp Start/End location)
    for (const TSharedPtr<FGameplayAbilityTargetData>& TargetData : TargetDataHandle.Data)
    {
        // 2. Lấy vị trí bắt đầu/kết thúc từ TargetData
        FVector StartLoc = TargetData->GetOrigin().GetTranslation(); // SourceLocation
        FVector EndLoc = TargetData->GetEndPoint();                 // TargetLocation

        // 3. Thiết lập Object Types (chỉ trace Pawn)
        TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes;
        ObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECC_Pawn));

        // 4. Thiết lập Actors to Ignore (nếu cần)
        TArray<AActor*> ActorsToIgnore;
        if (bIgnoreSelf)
        {
            ActorsToIgnore.Add(GetAvatarActorFromActorInfo());
        }

        // 5. Chế độ Debug (tùy chọn)
        EDrawDebugTrace::Type DrawDebugType = bDrawDebug ? EDrawDebugTrace::ForDuration : EDrawDebugTrace::None;

        // 6. Thực hiện Sphere Trace Multi
        TArray<FHitResult> Results;
        UKismetSystemLibrary::SphereTraceMultiForObjects(
            this,              // this thay vì GetWorld() → Sẽ gây crash nếu this không phải AActor
            StartLoc,          // Start location
            EndLoc,            // End location
            SphereSweepRadius, // Bán kính trace
            ObjectTypes,       // Loại object cần trace (Pawn)
            false,             // Trace complex (false = dùng simple collision)
            ActorsToIgnore,    // Actors bỏ qua
            DrawDebugType,     // Vẽ debug trace
            Results,           // Kết quả va chạm
            false              // Ignore bTraceComplex
        );

		for (const FHitResult& Result : Results)
		{
			if (HitActors.Contains(Result.GetActor()))
			{
                continue; // Bỏ qua nếu Actor đã bị trúng đòn trước đó
			}

			HitActors.Add(Result.GetActor()); // Thêm Actor vào HitActors nếu chưa bị trúng
			OutResult.Add(Result); // Thêm kết quả va chạm vào mảng kết quả
		}
    }

    return OutResult;
}

```

```cpp
//GA_Combo.h

#pragma once

#include "CoreMinimal.h"
#include "GAS/CGameplayAbility.h"
#include "Abilities/Tasks/AbilityTask_WaitGameplayEvent.h"
#include "GA_Combo.generated.h"

/**
 * 
 */
UCLASS()
class UGA_Combo : public UCGameplayAbility
{
	GENERATED_BODY()
	
public:
	UGA_Combo();
    virtual void ActivateAbility(
        const FGameplayAbilitySpecHandle Handle,
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo,
        const FGameplayEventData* TriggerEventData) override;
	static FGameplayTag GetComboChangedEventTag();
	static FGameplayTag GetComboChangedEventEndTag();
	static FGameplayTag GetComboTargetEventTag();

private:
	void SetupWaitComboInputPress();

	UFUNCTION()
	void HandleInputPress(float TimeWaited);

	void TryCommitCombo();

	UPROPERTY(EditDefaultsOnly, Category = "Animation")
	UAnimMontage* ComboMontage;

	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effect")
	TMap<FName, TSubclassOf<UGameplayEffect>> DamageEffectMap; // Map tên combo sang GameplayEffect

	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effect")
	TSubclassOf<UGameplayEffect> DefaultDamageEffect; // Hiệu ứng mặc định nếu không tìm thấy trong DamageEffectMap

	TSubclassOf<UGameplayEffect> GetDamageEffectForCurrentCombo() const; // Lấy hiệu ứng damage cho combo hiện tại

	UFUNCTION()
	void ComboChangedEventReceived(FGameplayEventData Data);

	UFUNCTION()
	void DoDamage(FGameplayEventData Data);

	FName NextComboName;
};

```

```cpp
//GA_Combo.cpp

#include "GAS/GA_Combo.h"
#include "Abilities/Tasks/AbilityTask_PlayMontageAndWait.h"
#include "Abilities/Tasks/AbilityTask_WaitInputPress.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayTagsManager.h"
#include "GAS/CAbilitySystemStatics.h"

UGA_Combo::UGA_Combo()
{
	AbilityTags.AddTag(UCAbilitySystemStatics::GetBasicAttackAbilityTag());
	BlockAbilitiesWithTag.AddTag(UCAbilitySystemStatics::GetBasicAttackAbilityTag());
}

void UGA_Combo::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!K2_CommitAbility())
	{
		K2_EndAbility();
		return;
	}
	
	if (HasAuthorityOrPredictionKey(ActorInfo, &ActivationInfo))
	{
		UAbilityTask_PlayMontageAndWait* PlayComboMontageTask = UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(
			this,
			NAME_None,
			ComboMontage);
		PlayComboMontageTask->OnBlendOut.AddDynamic(this, &UGA_Combo::K2_EndAbility);
		PlayComboMontageTask->OnCompleted.AddDynamic(this, &UGA_Combo::K2_EndAbility);
		PlayComboMontageTask->OnInterrupted.AddDynamic(this, &UGA_Combo::K2_EndAbility);
		PlayComboMontageTask->OnCancelled.AddDynamic(this, &UGA_Combo::K2_EndAbility);
		PlayComboMontageTask->ReadyForActivation();	

		UAbilityTask_WaitGameplayEvent* WaitComboChangeEventTask = UAbilityTask_WaitGameplayEvent::WaitGameplayEvent(
			this,
			GetComboChangedEventTag(),
			nullptr,
			false,
			false);
		WaitComboChangeEventTask->EventReceived.AddDynamic(this, &UGA_Combo::ComboChangedEventReceived);
		WaitComboChangeEventTask->ReadyForActivation();
	}

	if (K2_HasAuthority())
	{
		UAbilityTask_WaitGameplayEvent* WaitTargetingEventTask = UAbilityTask_WaitGameplayEvent::WaitGameplayEvent(this, GetComboTargetEventTag());
		WaitTargetingEventTask->EventReceived.AddDynamic(this, &UGA_Combo::DoDamage);
		WaitTargetingEventTask->ReadyForActivation();
	}
	SetupWaitComboInputPress();
}

FGameplayTag UGA_Combo::GetComboChangedEventTag()
{
	return FGameplayTag::RequestGameplayTag("ability.combo.change"); // Base tag
}

FGameplayTag UGA_Combo::GetComboChangedEventEndTag()
{
	return FGameplayTag::RequestGameplayTag("ability.combo.change.end");
}

FGameplayTag UGA_Combo::GetComboTargetEventTag()
{
	return FGameplayTag::RequestGameplayTag("ability.combo.damage");
}

void UGA_Combo::SetupWaitComboInputPress()
{
	UAbilityTask_WaitInputPress * WaitInputPress = UAbilityTask_WaitInputPress::WaitInputPress(this);
	WaitInputPress->OnPress.AddDynamic(this, &UGA_Combo::HandleInputPress);
	WaitInputPress->ReadyForActivation();
}

void UGA_Combo::HandleInputPress(float TimeWaited)
{
	// Tiếp tục lắng nghe input cho lần nhấn tiếp theo
	SetupWaitComboInputPress();
	//Thử chuyển sang combo tiếp theo
	TryCommitCombo();
}

void UGA_Combo::TryCommitCombo()
{
	if (NextComboName == NAME_None)	return;

	UAnimInstance* OwnerAnimInst = GetOwnerAnimInstance();
	if (!OwnerAnimInst) return;

	OwnerAnimInst->Montage_SetNextSection(OwnerAnimInst->Montage_GetCurrentSection(ComboMontage), NextComboName, ComboMontage);
}

TSubclassOf<UGameplayEffect> UGA_Combo::GetDamageEffectForCurrentCombo() const
{
	UAnimInstance* OwnerAnimInstance = GetOwnerAnimInstance();
	if (!OwnerAnimInstance)
	{
		FName CurrentSectionName = OwnerAnimInstance->Montage_GetCurrentSection(ComboMontage);
		const TSubclassOf<UGameplayEffect>* FoundEffectPtr = DamageEffectMap.Find(CurrentSectionName);
		if (FoundEffectPtr)
		{
			return *FoundEffectPtr;
		}
	}
	return DefaultDamageEffect;
}

void UGA_Combo::ComboChangedEventReceived(FGameplayEventData Data)
{
	FGameplayTag EventTag = Data.EventTag;

	if (EventTag == GetComboChangedEventEndTag())
	{
		NextComboName = NAME_None;
		return;
	}

	if (EventTag.MatchesTag(GetComboChangedEventTag()))
	{
		TArray<FName> TagNames;
		UGameplayTagsManager::Get().SplitGameplayTagFName(EventTag, TagNames);

		if (TagNames.Num() > 0)
		{
			NextComboName = TagNames.Last();
		}
	}
}

void UGA_Combo::DoDamage(FGameplayEventData Data)
{
	TArray<FHitResult> HitResults = GetHitResultsFromSweepLocationTargetData(Data.TargetData, 30.0f, true, true);

	for (const FHitResult& HitResult : HitResults)
	{
		TSubclassOf<UGameplayEffect> GameplayEffect = GetDamageEffectForCurrentCombo();
		FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec( 
			GameplayEffect, 
			GetAbilityLevel(GetCurrentAbilitySpecHandle(), 
			GetCurrentActorInfo())
		);

		ApplyGameplayEffectSpecToTarget(
			GetCurrentAbilitySpecHandle(),
			CurrentActorInfo,
			CurrentActivationInfo,
			EffectSpecHandle,
			UAbilitySystemBlueprintLibrary::AbilityTargetDataFromActor(HitResult.GetActor()));
	}
}

```